#include <octave/oct.h>

/// function [nulltemp, result_code] = create_nullspace__run_one_trial(I, cols_scaled, M, depths, central, opt)
DEFUN_DLD(create_nullspace__run_one_trial, args, nargsout,
          "Run a single trial of the create_nullspace route")
{
  int nargin = args.length();
  if (nargin != 6)
    {
      error("create_nullspace__run_one_trial required 6 parameters");
    }
  NDMatrix I = args(0).matrix_value();
  NDMatrix cols_scaled = args(1).matrix_value();
  NDMatrix M = args(2).matrix_value();
  NDMatrix depths = args(3).matrix_value();
  double central = args(4).scalar_value();
  Octave_map opt = args(5).map_value();
  
  // choose a 4/max-tuple
  unsigned m = I.dims()[0];
  unsigned n = I.dims()[1];


  ///cols = 1:n;
  ///rows = 1:m;
  ///use_maxtuples = 0;   % only for debugging
  ///
  ///cols_chosen = []; t=1; failed = 0; 
  ....

  ///if (central != 0)
  ///  scaled_ensured = 0; 
  ///else 
  ///  scaled_ensured = 1;   % trial version: no scale controling when cutting
  ///end
  bool scaled_ensured = (central == 0);

  unsigned t;
  for (t = 1; t <= 4; t++)
    {
      ///  % choose one column, cut useless parts etc.
      ///  [c, cols] = random_element(cols);
      ...
      ///  cols_chosen = [cols_chosen c];
      ...

      ///  % check just added column
      ///  rows = intersect(rows, find(I(:,c) > 0));
      ...

      /// if t < 4,
      ///   [rows, cols, scaled_ensured] = cut_useless(I, cols_scaled, ...
      ///                             cols_chosen, rows, cols, 4-t, scaled_ensured);
      if (t < 4)
	{
	  unsigned demanded = 4 - t;
	  // daveb: The remainder of the body of the if t<4 statement, is an implementation of cut_useless.
	  if (!scaled_ensured)
	    {
	      unsigned demanded_scaled, demanded_rows;
	      if (length(rows) == 2)
		{
		  demanded_scaled = 3;
		  demanded_rows = 2; 
		}
	      else
		{
		  demanded_scaled = 3;
		  demanded_rows = 2; 
		}
	      unsigned n_cols_scaled_chosen = 0;
	      for (i = 0; i < n_cols_chosen; i++)
		if (cols_scaled[i] > 0)
		  n_cols_scaled_chosen++;
      
	      // if no unscaled are allowed, they must be all cut
	      if (demanded == demanded_scaled - n_cols_scaled_chosen)
		{
		  cols           = intersect(cols, find(cols_scaled > 0));
		  scaled_ensured = 1;
		}
	    }
    
	  // check columns
	  ///cols = cols(find(sum(I(rows,cols)) >= demanded_rows));
	  cols = cols(find(sum(I(rows,cols)) >= demanded_rows));

	  // check rows
	  ///rows = rows(find(sum(I(rows,cols)') >= demanded));
	  rows = rows(find(sum(I(rows,cols)') >= demanded));
	}

      ///  if isempty(rows), failed = 1; break; end
      if (n_rows == 0)
	{
	  failed = true;
	  break; 
	}
    }
  

  octave_value_list return_values;
  if (failed)
    {
      // prepare to return nulltemp=[], result_code=0
      return_values.append(matrix_value());
      return_values.append(octave_scalar(0));
    }
  else
    {
      // use the 4/max-tuple 
      ///  d = depths(rows,cols_chosen);
      d = depths(rows,cols_chosen);

      ///  rowsbig   = k2i(rows);
      ///  submatrix=[];
      ///  for j=1:length(cols_chosen) % 4
      ///    submatrix = [ submatrix ... spread_depths_col(M(rowsbig,cols_chosen(j)), d(:,j)) ]
      ///  end
      ///  subnull = nulleps(submatrix,opt.threshold); %svd(submatrix)
      ///  if size(subnull,2)>0  &&  (size(submatrix,1) == size(submatrix,2) + size(subnull,2))
      if (...)
	{
	  ///    nulltemp            = zeros(size(M,1),size(subnull,2));
	  ///    nulltemp(rowsbig,:) = subnull; % * (length(rows)/m); % weighting
	  ///    result_code = 2;
	  return_values.append(octave_scalar(2));
	}
      else
	{
	  /// nulltemp = [];
	  return_values.append(matrix_value());
	  /// result_code = 1;
	  return_values.append(octave_scalar(2));
	}
    }
  return return_values;
}

