// Implement part of create_nullspace(), called create_nullspace__run_one_trial()
// to optimize the slowest routine in the code.
//
// By Dave Benson, 2010.

// Implements:
//   function [nulltemp, result_code] = create_nullspace__run_one_trial(I, cols_scaled, M, depths, central, opt)
// See: create_nullspace__run_one_trial() in create_nullspace.m.

// STATUS: INCOMPLETE

#include <octave/oct.h>

/// function [nulltemp, result_code] = create_nullspace__run_one_trial(I, cols_scaled, M, depths, central, opt)
DEFUN_DLD(create_nullspace__run_one_trial, args, nargsout,
          "Run a single trial of the create_nullspace route")
{
  int nargin = args.length();
  if (nargin != 6)
    {
      error("create_nullspace__run_one_trial required 6 parameters");
    }
  NDMatrix I = args(0).matrix_value();
  NDMatrix cols_scaled = args(1).matrix_value();
  NDMatrix M = args(2).matrix_value();
  NDMatrix depths = args(3).matrix_value();
  double central = args(4).scalar_value();
  Octave_map opt = args(5).map_value();
  
  // choose a 4/max-tuple
  unsigned m = I.dims()[0];
  unsigned n = I.dims()[1];


  ///cols = 1:n;
  unsigned n_cols_remaining = n;
  unsigned *cols_remaining;
  OCTAVE_LOCAL_BUFFER (unsigned, cols_remaining, n);
  for (i = 0; i < n; i++)
    cols_remaining[i] = i;

  ///rows = 1:m;
  ///use_maxtuples = 0;   % only for debugging
  ///
  ///cols_chosen = []; t=1; failed = 0; 
  unsigned n_cols_chosen = 0;
  unsigned *cols_chosen;
  OCTAVE_LOCAL_BUFFER (unsigned, cols_chosen, n);
  bool failed = false;

  ///if (central != 0)
  ///  scaled_ensured = 0; 
  ///else 
  ///  scaled_ensured = 1;   % trial version: no scale controling when cutting
  ///end
  bool scaled_ensured = (central == 0);

  unsigned t;
  unsigned n_cols_scaled_chosen = 0;		// maintained as invariant instead of computed on demand
  for (t = 1; t <= 4; t++)
    {
      ///  % choose one column, cut useless parts etc.
      ///  [c, cols] = random_element(cols);
      unsigned rand_index = rand() % n_cols_remaining;		/// XXX: use better RNG
      unsigned c = cols_remaining[rand_index];
      cols_remaining[rand_index] = cols_remaining[n_cols_remaining - 1];
      n_cols_remaining--;

      ///  cols_chosen = [cols_chosen c];
      cols_chosen[n_cols_chosen++] = c;

      if (cols_scaled[c] > 0.0)
        n_cols_scaled_chosen++;

      ///  % check just added column
      ///  rows = intersect(rows, find(I(:,c) > 0));
      ...

      /// if t < 4,
      ///   [rows, cols, scaled_ensured] = cut_useless(I, cols_scaled, ...
      ///                             cols_chosen, rows, cols, 4-t, scaled_ensured);
      if (t < 4)
	{
	  unsigned demanded = 4 - t;
	  // daveb: The remainder of the body of the if t<4 statement, is an implementation of cut_useless.
	  if (!scaled_ensured)
	    {
	      unsigned demanded_scaled, demanded_rows;
	      if (length(rows) == 2)
		{
		  demanded_scaled = 3;
		  demanded_rows = 2; 
		}
	      else
		{
		  demanded_scaled = 3;
		  demanded_rows = 2; 
		}
      
	      // if no unscaled are allowed, they must be all cut
	      if (demanded == demanded_scaled - n_cols_scaled_chosen)
		{
		  cols           = intersect(cols, find(cols_scaled > 0));
		  scaled_ensured = 1;
		}
	    }
    
	  // check columns
	  ///cols = cols(find(sum(I(rows,cols)) >= demanded_rows));
	  cols = cols(find(sum(I(rows,cols)) >= demanded_rows));

	  // check rows
	  ///rows = rows(find(sum(I(rows,cols)') >= demanded));
	  rows = rows(find(sum(I(rows,cols)') >= demanded));
	}

      ///  if isempty(rows), failed = 1; break; end
      if (n_rows == 0)
	{
	  failed = true;
	  break; 
	}
    }
  

  octave_value_list return_values;
  if (failed)
    {
      // prepare to return nulltemp=[], result_code=0
      return_values.append(matrix_value());
      return_values.append(octave_scalar(0));
    }
  else
    {
      // use the 4/max-tuple 
      ///  d = depths(rows,cols_chosen);
      d = depths(rows,cols_chosen);

      ///  rowsbig   = k2i(rows);
      ///  submatrix=[];
      ///  for j=1:length(cols_chosen) % 4
      for (j = 1; j <= n_cols_chosen; j++)
        {
	  ///spread = spread_depths_col(M(rowsbig,cols_chosen(j)), d(:,j))
          //////% Mdepthcol is column of JIM with depths which is spread by this
          //////% function to a submatrix with some zeros
          //////function submatrix = spread_depths_col(Mdepthcol,depthsIcol)
          //////
          //////m = size(depthsIcol,1);
          //////n = 1;
          //////
          //////known_depths      = find(depthsIcol ~= 0);
          //////
          //////if ~isempty(known_depths)
          //////  rows              = k2i(known_depths);
          //////  submatrix(rows,n) = Mdepthcol(rows); n=n+1;
          //////end
          //////
          //////for i=setdiff(1:m, known_depths)
          //////  rows              = k2i(i);
          //////  submatrix(rows,n) = Mdepthcol(rows); n=n+1;
          //////end
	  ...

          ///submatrix = [ submatrix , spread ]
	  ...
	}

      ///  end
      ///  subnull = nulleps(submatrix,opt.threshold); %svd(submatrix)
      ///  if size(subnull,2)>0  &&  (size(submatrix,1) == size(submatrix,2) + size(subnull,2))
      if (...)
	{
	  ///    nulltemp            = zeros(size(M,1),size(subnull,2));
	  ///    nulltemp(rowsbig,:) = subnull; % * (length(rows)/m); % weighting
	  ///    result_code = 2;
	  return_values.append(octave_scalar(2));
	}
      else
	{
	  /// nulltemp = [];
	  return_values.append(matrix_value());
	  /// result_code = 1;
	  return_values.append(octave_scalar(2));
	}
    }
  return return_values;
}

